% conclusion.tex

% Conclusion
\section{Conclusion}
\label{sec:conclusion}
This paper presents graphics acceleration by the means of paravirtualization in the Simics full-system simulator.
The implementation generates EGL and OpenGL libraries and communicates with low-latency magic instructions.
To evaluate the implementation, benchmarks are developed to highlight solution weaknesses and strengths; an analysis of results is presented, as well as benefits and drawbacks of paravirtualized methodology.

In Section~\ref{sec:results}, compiled results showcase great improvements for computationally intensive graphics.
Performance is improved by up to $34$ times, reducing frame time from $1415$~\milli\second\ to $42$~\milli\second ; a frame time of $42$~\milli\second\ roughly correspond to 24 FPS.
Furthermore, paravirtualization lower maximum frame times, significantly improving standard deviation.
Compared to software rasterization, paravirtualization is estimated to obtain an additional order of magnitude faster frame time without hardware-assisted virtualization.

Along with performance improvements, Section~\ref{sec:results} detail a communications latency issue inherent in magic instruction overhead.
This emerges as a performance bottleneck inherent in great numbers of paravirtualized function invocations.
While magic instructions are -- evidently -- fast enough to accomodate real-time graphics, improvements to this overhead should greatly improve their capacity.

To conclude: this paper demonstrates accelerated graphics in Simics using paravirtualization with magic instructions as a communications bridge.
Graphics acceleration in Simics is relevant because it fascilitates debugging, testing, and profiling of software that depends on GPU utilization.
Consequently, paravirtualization is practical because it offers a good development cost and performance trade-off.
The findings of this paper may help in extending the use of Simics to application development dependent on GPUs, including computer graphics and general-purpose workloads.

Benefits are performance improvements of up to two orders of magnitude, paired with larger benefits in non-hardware accelerated use-cases.
Magic instruction overhead is identified as the performance bottleneck.
As such, a drawback is a weakness to large amounts of framework invocations.
Accordingly, the findings of this paper contributes to our understanding of the difficulties facing graphics acceleration in virtual platforms by demonstrating the use of paravirtualization as a successful formula to accelerate graphics in Simics.

% future work

The presented implementation may be advanced in a number of ways to support a higher number of platforms and subject to an array of performance enhancements.
Below, recommendations for future study are presented.

In terms of performance, command serialization batching should be considered for the purposes of minimizing the number of performed magic instructions.
That is, the ability to queue framework invocations and transmit them in a batch rather than individually.
Considering that magic instructions are a performance bottleneck, such an optimization could drastically improve simulation performance.
Furthermore, such an optimization could be paired with WireGL, an OpenGL rendering distribution library~\masccite{web:stanford:2015}.

Often, it is desirable to simulate systems other than the simulation host.
One could pose the scenario of a Linux host system simulating a machine running a Windows OS.
In this case, it is possible that target software utilize the DirectX framework to render graphics, whereas the host Linux system only feature the OpenGL libraries.

In $2014$, Valve released open-source software capable of converting DirectX~$9.0$c-code to that of OpenGL~\masccite{technicaldocs:valve:2014}.
Albeit limited in its capabilities, the functionality of translating between one, platform-specific, framework to that of a cross-platform one may be practical for the purposes of graphics acceleration in virtual platforms.
An inherent flaw in paravirtualizing graphics APIs is that a target application may only make use of accelerated simulation performance if that application is implemented using the API in question.
If such a solution could be used to translate the rendering of a target program on-the-fly in a virtual machine, this might bridge the gap between the performance gains of using paravirtualization and other -- albeit slower, generalized ways of virtualizing graphics for any platform.
Thus, the adaption of this sort of software could extend the capabilities and area-of-application of graphics paravirtualization in the Simics full-system simulator.

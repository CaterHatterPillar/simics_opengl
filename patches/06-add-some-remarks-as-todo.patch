Add some remarks, as \todo annotations

From: Erik Carstensen <erik.carstensen@intel.com>


---
 src/introduction.tex      |    2 +-
 src/methodsandresults.tex |   26 +++++++++++++-------------
 src/previousresearch.tex  |   12 ++++++------
 3 files changed, 20 insertions(+), 20 deletions(-)

diff --git a/src/introduction.tex b/src/introduction.tex
index cd5fe5c..5062f90 100644
--- a/src/introduction.tex
+++ b/src/introduction.tex
@@ -21,7 +21,7 @@ Since GPUs operate significantly different from CPUs, utilizing massively parall
 The increased utilization of GPUs for general purpose workloads has extended the need for virtualization of such hardware in situations when hardware is busy, unavailable, not sufficient, or for the purposes of debugging and profiling~\dvtcmdciteref{web:microsoft:2013:warp}.
 For example, developers interested in benchmarking or driver development for next generation GPUs or CPUs may require detailed simulators that provide insight into execution engines and pipelines~\dvtcmdcitebib[p.~1]{inproceedings:schumacher:2010}.
 Albeit applicable in certain use-cases and capable of running 'toy' applications, such platforms are often orders of magnitude too slow to run commercial workloads~\dvtcmdcitebib[p.~50]{journals:magnusson:2002}.
-Application developers, on the other hand, do not necessarily care for the internal workings of hardware as they typically work at a higher abstraction level.
+Application developers,\todo{also relevant for non-graphics low-level programming running in an UI environment} on the other hand, do not necessarily care for the internal workings of hardware as they typically work at a higher abstraction level.
 As such, some developers may be more interested in achieving decent simulation performance rather than a timing-accurate processor model (see \dvtcmdcitebib[p.~30]{publications:leupers:2010} for an analysis of compromises in system simulation).
 However, due to large differences between CPU and GPU architecture, simply delegating GPU-bound workloads to the CPU is rarely feasible in terms of performance.
 
diff --git a/src/methodsandresults.tex b/src/methodsandresults.tex
index cd9f015..c23ab13 100644
--- a/src/methodsandresults.tex
+++ b/src/methodsandresults.tex
@@ -13,7 +13,7 @@ These components, along with elaboration of the methodologies accomodating them,
 For the purposes of ensuring scalability of the solution during development, a set of scripts automating the generation of library source code is used to compile the majority of target and host system libraries.
 As such, a large amount of the OpenGL function definitions encoded and decoded by the these libraries are produced by this tool.
 For this, we use a \texttt{Python} program that, from framework specification files detailing function signatures and argument attributes, generate both headers and source files in \texttt{C}, thus constructing the target OpenGL and EGL frameworks, along with the corresponding host decoding libraries.
-The tool generates all but the methods that need special treatment (due to state saving) and may thus generate methods with return values and inout arguments.
+The tool generates all but the methods that need special treatment (due to state saving) and may thus generate methods with return values and inout\todo{inout vedertaget begrepp?} arguments.
 
 \subsection{Target System Libraries}
 \label{sec:proposedsolutionandimplementation_targetsystemlibraries}
@@ -70,13 +70,13 @@ The Simics pipe constitutes the target-to-host communications channel in Simics.
 As such, it is responsible for transferring a serialized command stream between target software and simulation host.
 In order to do this, the pipe requires a way to exchange information with the outside world.
 
-There may be reasons as to why one would like to escape the simulation and resume execution in the real world.
-Such a scenario would be a debugging breakpoint, to share data in-between target and host systems, or for any reason modify the simulation state.
+There may be reasons why target software would like to escape the simulation and trigger that execution is resumed on the simulation host.
+Such a scenario would be a debugging breakpoint, to share data between target and host systems, or for any reason modify the simulation state \todo{I don't understand this sentence}.
 There are a number of ways to communicate with the outside world (including the host machine) from within the simulation, such as by networking means or specially devised kernel drivers, but few are as instant as the -- arguably -- legitimately coined 'magic instruction'.
 
 The magic instruction is a concept used to denote a \dvtcmdcodeinline{nop}-type instruction, meaning an instruction that would have no effect if run on the target architecture (such as \dvtcmdcodeinline{xchg ebx, ebx} on the x86), which, when executed on the simulated hardware in a virtual platform, invokes a callback-method in the simulation host~\dvtcmdcitebib[p.~32]{publications:leupers:2010}.
 An advantage of this methodology is an often negligible invocation cost, as the context switch is often instant from the perspective of the target system~\dvtcmdcitebib[p.~131]{journals:rechistov:2013}.
-Furthermore, being a greatly desirable attribute, magic instructions require no modification of the target system.
+Furthermore, being a greatly desirable attribute, magic instructions require no modification of the target system \todo{joho! magiska instr ar ju en modifiering av target, man andrar ju pa instruktioner. Syftar du pa att man inte behover lagga till latsashardvara? eller att mjukvara med MI aven funkar pa riktig HW? om det senare, sa ar detta orelevant for paravirtualisering}.
 In effect, implementation of magic instructions requires replacing one or more instructions in the target instruction set, thereby making the magic instruction platform-dependent.
 However, the solution is often designed to only respond to magic instructions wherein a certain magic number, sometimes called a 'leaf number'~\dvtcmdcitebib[p.~131]{journals:rechistov:2013}, is present in an arbitrary processor register.
 
@@ -122,8 +122,8 @@ Naturally, said process must be performed regardless whether data is being read
 
 \subsection{Experimental Methodology}
 \label{sec:experimentalmethodology}
-The experiment is performed in software rasterized- and paravirtualized Simics platforms, respectively, in addition to reference runs on the host system.
-Simics is configured to simulate an Intel\circledR\ Core \texttrademark\ i7; the same processor series to that of simulation host hardware.
+The experiment is performed in software rasterized and paravirtualized Simics platforms, respectively, in addition to reference runs on the host system.
+Simics is configured to simulate an Intel\circledR\ Core \texttrademark\ i7\todo{i7 is not a processor series, it's a marketing brand. I suppose the crucial similarity is that both use 64-bit x86 architectures?}, the same processor series to that of simulation host hardware.
 During simulation, we utilize KVM to accelerate simulation by running target x86 instructions natively on host (x86) hardware.
 The simulation systems are, like the host system, set up to run Fedora $19$ Linux and use the Mesa llvmpipe driver for OpenGL software rasterization.
 
@@ -168,7 +168,7 @@ benchmark.
 \end{figure}
 
 % Benchmark: Chess
-\paragraph{Benchmark: Chess}
+\paragraph{Benchmark: Chess\todo{incorrect paragraph numbering}}
 \label{par:experimentalmethodology_benchmarking_benchmarkchess}
 \index{Chess benchmark}
 The 'Chess' benchmark is developed for the purposes of stressing the latency between target and host systems.
@@ -197,7 +197,7 @@ The case is selected for use as the computation of a fractal is trivially scalab
 
 We perform the Julia benchmark with $225$, $450$, and $900$ iterations per frame, all of which induce $16$ magic instructions per frame.
 
-\subsubsection{Platform Profiling}
+\subsubsection{Platform Profiling\todo{strange numbering again}}
 \label{sec:platformprofiling}
 In the presence of complications caused by virtual time, profiling of elapsed time in simulators dictate special measures.
 This is due to the fact that profiling of elapsed time outside of the simulation -- that is, time in the context of the observer -- may be more relevant than profiling of virtual time.
@@ -218,10 +218,10 @@ If not specified otherwise, all results have taken into account the average of t
 
 \subsection{Results}
 \label{sec:results}
-Results gathered from execution on the host are presented in table~\ref{tab:keyvalhost} and results compiled from execution in \hl{QEMU} are presented in table\ref{tab:keyvalqemu}, while results accumulated from software rasterized and paravirtualized execution in Simics are presented in tables~\ref{tab:keyvalsimics}~and~\ref{tab:keyvalpara}.
-In figures~\ref{fig:histogramssimicsparachess}~and~\ref{fig:histogramssimicsparajulia}, the results are presented as histograms; visualizing elapsed time in milliseconds to sample density.
-As such, the $Y$ axis showcase sample density; although the axis keys have been removed as they bear little relevance to the outcomes presented in this material.
-The histograms each feature $100$ bins; into which a $1000$ samples, for each experiment performed, are rounded into.
+Results gathered from execution on the host are presented in table~\ref{tab:keyvalhost} and results compiled from execution in \hl{QEMU} are presented in table~\ref{tab:keyvalqemu}, while results accumulated from software rasterized and paravirtualized execution in Simics are presented in tables~\ref{tab:keyvalsimics}~and~\ref{tab:keyvalpara}.
+In figures~\ref{fig:histogramssimicsparachess}~and~\ref{fig:histogramssimicsparajulia}, the results are presented as histograms, visualizing elapsed time in milliseconds to sample density.
+As such, the $Y$ axis showcase sample density, although the axis keys have been removed as they bear little relevance to the outcomes presented in this material.
+The histograms each feature $100$ bins, into which $1000$ samples, for each experiment performed \todo{unclear reference -- Do you mean that for each experiment, you put 1000 samples into 100 bins? maybe clearer if you split in 2 sentences}, are rounded into.
 For the purposes of visualization, values outside of the standard deviation are not featured in the figures.
 The remainder of this section presents an analysis of the data compiled from executing the experiment on the software rasterized and paravirtualized Simics platforms.
 
@@ -330,7 +330,7 @@ It also entails Simics no longer being able to utilize just-in-time compilation
 As such, in great numbers, magic instructions may greatly affect performance.
 
 We performed further study into this matter to establish what those overhead costs may be.
-To do this, we measured elapsed time for escaping simulation $1000$ times using magic instructions, collecting minimum (\dvtcmdfirstline{magicinstrprofileall.dat.min}), maximum (\dvtcmdfirstline{magicinstrprofileall.dat.max}), average (\dvtcmdfirstline{magicinstrprofileall.dat.avg}), the standard deviation thereof (\dvtcmdfirstline{magicinstrprofileall.dat.std}), time to do so.
+To do this, we measured elapsed time for escaping simulation $1000$ times using magic instructions, collecting minimum (\dvtcmdfirstline{magicinstrprofileall.dat.min}), maximum (\dvtcmdfirstline{magicinstrprofileall.dat.max}), average (\dvtcmdfirstline{magicinstrprofileall.dat.avg}), the standard deviation thereof (\dvtcmdfirstline{magicinstrprofileall.dat.std}), time to do so \todo{kan meningen forenklas lite? lite val komplexa syftningar}.
 From these findings, we may conclude that the execution of $1000$ magic instructions is expected to induce an average overhead of \dvtcmdfirstline{magicinstrprofileall.dat.avg}~ms per magic instruction.
 Indeed, these findings indicate that magic instruction overhead could very well account for the majority of the elapsed average frametimes when paravirtualized in Simics.
 
diff --git a/src/previousresearch.tex b/src/previousresearch.tex
index eebb130..0f01199 100644
--- a/src/previousresearch.tex
+++ b/src/previousresearch.tex
@@ -7,9 +7,8 @@ System simulators are abundant and exist in corporate~\dvtcmdcitebib{magazines:b
 Such platforms, like Simics, have been used for a variety of purposes including, but not limited to, thermal control strategies in multicores~\dvtcmdcitebib{inproceedings:bartolini:2010}, networking timing analysis~\dvtcmdcitebib{journals:ortiz:2009}, web server performance evaluation~\dvtcmdcitebib{journals:villa:2005}, and to simulate costly hardware financially unfeasible to researchers~\dvtcmdcitebib{journals:alameldeen:2003}.
 Furthermore, these simulators may also be used to port OSs to new processors~\dvtcmdciteref{technicaldocs:netbsd:2014}.
 
-For the purposes of graphics acceleration in virtual platforms, strategies are numerous.
-From a number of core strategies, such as device modeling, passthrough technologies, and paravirtualization, there are several attempts at accelerating simulator graphics; many of which require modification of both target and host systems.
-One such instance is presented by Hansen in his work on the Blink display system~\dvtcmdcitebib{inproceedings:hansen:2007}.
+Several attempts have been made to accelerate simulator graphics. Many of these require modification of both target and host systems.
+One such instance is presented by Hansen in his work on the Blink display system~\dvtcmdcitebib{inproceedings:hansen:2007}.\todo{mention smth about the strategy used?}
 Another is VMGL by Lagar-Cavilla et al., who accelerates OpenGL~$1.5$ roughly two orders of magnitude using paravirtualization~\dvtcmdcitebib{inproceedings:lagarcavilla:2007}.
 
 QEMU ('Quick~Emulator') is an open-source virtual platform described as a full system emulator~\dvtcmdcitebib[p.~1]{inproceedings:bellard:2005} and a high-speed functional simulator~\dvtcmdcitebib[p.~1]{inproceedings:shen:2010}.
@@ -68,6 +67,7 @@ Yet the methodology suffers from several disadvantages, such as requiring dedica
 In terms of GPU virtualization, this would induce the necessity of multiple graphics cards to the host system.
 Additionally, and perhaps the greatest flaw of passthrough technologies, is the requirement of modifying the simulation target to utilize host hardware, effectively restricting what systems may be simulated.
 This restriction encompasses the utilization of corresponding device drivers to the host system, rendering the methodology inflexible in terms of GPU virtualization diversity.
+\todo{IIRC, PCI passthrough necessarily destroys checkpointing and revexec, maybe we should mention that?}
 
 % Paravirtualization
 \paragraph{Paravirtualization}
@@ -76,12 +76,12 @@ At a higher level of abstraction, there is the option of virtualization by parav
 By selectively modifying target system, we may control the inner workings of system attributes and add functionality such as graphics hardware support.
 For graphics acceleration, such a system attribute may be a graphics library or a kernel driver (see figure \ref{fig:overview}).
 
-Inherent by higher abstraction, paravirtualization may be relatively cost-effective in comparison to device modeling.
+Inherent by higher abstraction, paravirtualization may be relatively cost-effective\todo{cost-effective in what sense? performance, development cost?} in comparison to device modeling.
 Additionally, by selectively modifying at the graphics library software level, there is no need for users to modify the application they wish to accelerate.
-Furthermore, by utilizing fast communications channels, one may accommodate for significant performance gains when compared to networking solutions (see section \ref{sec:proposedsolutionandimplementation_simicspipe}).
+Furthermore, by utilizing fast communications channels, one may accommodate for significant performance gains when compared to networking solutions\todo{avoid forward references. Maybe just remove the sentence? Or elaborate with enough context to make it understandable by itself, but probably not worth it} (see section \ref{sec:proposedsolutionandimplementation_simicspipe}).
 Unfortunately, paravirtualization is not without inherent flaws.
 In particular, a paravirtualized graphics library may be expensive to maintain as frameworks evolve and specifications change.
-Additionally, paravirtualized methodologies requires modification of target systems; albeit not necessarily being a defect as a paravirtualized framework may still accelerate unmodified target applications.
+Additionally, paravirtualized methodologies require modification of target systems; albeit not necessarily being a defect as a paravirtualized framework may still accelerate unmodified target applications \todo{i don't understand this statement}.
 
 For the purposes of graphics acceleration in a virtual platform, paravirtualization offers a decent balance between benefits and drawbacks, and is therefore considered a suitable candidate for accelerating graphics in the Simics full-system simulator.
 

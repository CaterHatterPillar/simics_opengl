Minor language fixes

From: Erik Carstensen <erik.carstensen@intel.com>


---
 src/conclusion.tex        |    4 ++--
 src/methodsandresults.tex |    8 ++++----
 src/previousresearch.tex  |    4 ++--
 3 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/src/conclusion.tex b/src/conclusion.tex
index d549129..07be7a8 100644
--- a/src/conclusion.tex
+++ b/src/conclusion.tex
@@ -11,8 +11,8 @@ Furthermore, compiled results have showcased great improvements for computationa
 As such, we have accelerated graphics by up to $34$ times, reducing frame time from that of \dvtcmdfirstline{simicsjulia900.dat.avg}~ms to the real-time feasible count of \dvtcmdfirstline{parajulia900.dat.avg}~ms.
 It is likely that this performance improvement would be orders of magnitude greater for virtual platforms that do not utilize hardware-assisted virtualization, such as when using Simics to simulate other systems than x86-compatible ones, or when using breakpoints.
 Accordingly, our experiment has identified the potential of using paravirtualization for the means of accelerating graphics to that of real-time performance, testimonial to the results presented by Lagar-Cavilla et al. in their work on using paravirtualization to accelerate graphics~\dvtcmdcitebib{inproceedings:lagarcavilla:2007}.
-Additionally, beyond that of accelerated graphics, results indicates performance improvements in terms of maximum frametimes, inducing significantly improved standard deviation.
-In line with stable frame rates being prerequisites for real-time applications, this further indicate, in coagency with reduced frametimes, the feasibility of utilizing paravirtualized methodologies for the purposes of accelerating graphics within virtual platforms.
+Additionally, beyond that of accelerated graphics, results indicate performance improvements in terms of maximum frametimes, inducing significantly improved standard deviation.
+In line with stable frame rates being prerequisites for real-time applications, this further indicates, in coagency with reduced frametimes, the feasibility of utilizing paravirtualized methodologies for the purposes of accelerating graphics within virtual platforms.
 
 To summarize: We have presented a solution for graphics acceleration implemented in the Simics full-system simulator by the means of paravirtualization.
 The end-result is a solution which may generate libraries imitating EGL and OpenGL~ES~$2.0$ libraries.
diff --git a/src/methodsandresults.tex b/src/methodsandresults.tex
index bdbe3a2..234c7be 100644
--- a/src/methodsandresults.tex
+++ b/src/methodsandresults.tex
@@ -18,7 +18,7 @@ The tool generates all but the methods that need special treatment (due to state
 \subsection{Target System Libraries}
 \label{sec:proposedsolutionandimplementation_targetsystemlibraries}
 Compiled from \texttt{C} and \texttt{C++} sources output by the generation program, the target system libraries compose implementations of the EGL and OpenGL APIs.
-Due to the tight coupling ibetween OpenGL and the platform windowing system, the solution must also accelerate the Khronos EGL API -- the interface between OpenGL and the underlying platform windowing system.
+Due to the tight coupling between OpenGL and the platform windowing system, the solution must also accelerate the Khronos EGL API -- the interface between OpenGL and the underlying platform windowing system.
 As may be derived from the name, the target system libraries run on the simulation target system and replace any existing Khronos libraries.
 
 Accordingly, the target system libraries implement the EGL and OpenGL~ES~$2.0$ APIs and lures whatever application it is being linked to that it is, in fact, the expected platform libraries.
@@ -80,7 +80,7 @@ Furthermore, being a greatly desirable attribute, magic instructions require no
 In effect, implementation of magic instructions requires replacing one or more instructions in the target instruction set, thereby making the magic instruction platform-dependent.
 However, the solution is often designed to only respond to magic instructions wherein a certain magic number, sometimes called a 'leaf number'~\dvtcmdcitebib[p.~131]{journals:rechistov:2013}, is present in an arbitrary processor register.
 
-Due to the inherent performance demands brought on by serialization of real-time graphics invocations, magic instructions are a suitable candidate to exchange information between target host systems.
+Due to the inherent performance demands brought on by serialization of real-time graphics invocations, magic instructions are a suitable candidate for the exchange of information between target and host system.
 Magic instructions allow for fast, in the pretext of the simulation target -- almost instant -- escape from the simulation context, and may carry a limited amount of information with it from inside the simulation out into the real world.
 The role of the Simics pipe is comprised of the allocation and maintenance of page locked target memory to accomodate the use of magic instructions, which the Simics pipe uses to relay the starting address of said memory space to the simulation host.
 
@@ -174,7 +174,7 @@ It is so named because of the chess-like tileset the graphics kernel produces.
 The benchmark is designed to perform a multitude of OpenGL~ES~$2.0$ library invocations per frame, in which each invocation is relatively lightweight in execution and carries a small amount of data in its arguments.
 In the Chess benchmark, this is achieved by rendering a grid of colored (black or white, in order to adhere to the chess paradigm) rectangles where each tile is represented by four two-dimensional vertices in screen-space, in addition to six indices outlining the rectangular shape.
 Since the vertices are already transformed into screen-space, the graphics kernel need perform no additional transformation, adhering to the desired lightweight behavior of each kernel invocation.
-Additionally, the tileset vertices and indices are pre-loaded into OpenGL vertex and index element buffers, so that a lone buffer identifier may be carried over in-place of the heavier vertex set load.
+Additionally, the tileset vertices and indices are pre-loaded into OpenGL vertex and index element buffers, so that a lone buffer identifier may be transferred instead of the heavier vertex set load.
 Each tile is then individually drawn to the backbuffer, rendering the chess-like appearance of the benchmark.
 Effectively, this means that, for each tile, the benchmark need only bind a vertex and an index element buffer, set the corresponding tile color, and lastly invoke the rendering of said tile.
 
@@ -330,7 +330,7 @@ As such, in great numbers, magic instructions may greatly affect performance.
 We performed further study into this matter to establish what those overhead costs may be.
 To do this, we measured elapsed time for escaping simulation $1000$ times using magic instructions, collecting minimum (\dvtcmdfirstline{magicinstrprofileall.dat.min}), maximum (\dvtcmdfirstline{magicinstrprofileall.dat.max}), average (\dvtcmdfirstline{magicinstrprofileall.dat.avg}), the standard deviation thereof (\dvtcmdfirstline{magicinstrprofileall.dat.std}), time to do so.
 From these findings, we may conclude that the execution of $1000$ magic instructions is expected to induce an average overhead of \dvtcmdfirstline{magicinstrprofileall.dat.avg}~ms per magic instruction.
-Indeed, these findings indicate that magic instruction overhead could ver well account for the majority of the elapsed average frametimes when paravirtualized in Simics.
+Indeed, these findings indicate that magic instruction overhead could very well account for the majority of the elapsed average frametimes when paravirtualized in Simics.
 
 In figure \ref{fig:histogramssimicsparajulia}, we may observe double to triple peak behavior in the distribution of the sample density, both in software rasterized and paravirtualized platforms.
 What causes this behavior is unclear, as frame-to-frame branching in the fractal algorithm is minor and ought not cause such a variance.
diff --git a/src/previousresearch.tex b/src/previousresearch.tex
index ad48d29..eebb130 100644
--- a/src/previousresearch.tex
+++ b/src/previousresearch.tex
@@ -66,7 +66,7 @@ PCI~passthrough technologies allow virtual systems first-hand access to host mac
 The direct contact with host system devices accommodated by these technologies enable fully-fledged hardware accelerated workloads.
 Yet the methodology suffers from several disadvantages, such as requiring dedicated hardware, causing the host system to lose access to devices during the course of simulation.
 In terms of GPU virtualization, this would induce the necessity of multiple graphics cards to the host system.
-Additionally, and mayhaps the gratest flaw of passthrough technologies, is the requirement of modifying the simulation target to utilize host hardware; effectively restricting what systems may be simulated.
+Additionally, and perhaps the greatest flaw of passthrough technologies, is the requirement of modifying the simulation target to utilize host hardware, effectively restricting what systems may be simulated.
 This restriction encompasses the utilization of corresponding device drivers to the host system, rendering the methodology inflexible in terms of GPU virtualization diversity.
 
 % Paravirtualization
@@ -83,7 +83,7 @@ Unfortunately, paravirtualization is not without inherent flaws.
 In particular, a paravirtualized graphics library may be expensive to maintain as frameworks evolve and specifications change.
 Additionally, paravirtualized methodologies requires modification of target systems; albeit not necessarily being a defect as a paravirtualized framework may still accelerate unmodified target applications.
 
-For the purposes of graphics acceleration in a virtual platform, paravirtualization is a decent levelling of benefits and drawbacks, and is therefore considered a suitable candidate for accelerating graphics in the Simics full-system simulator.
+For the purposes of graphics acceleration in a virtual platform, paravirtualization offers a decent balance between benefits and drawbacks, and is therefore considered a suitable candidate for accelerating graphics in the Simics full-system simulator.
 
 %% % Virtual Time
 %% \subsection{Virtual Time}

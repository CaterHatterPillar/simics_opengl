Change - into -- in a couple of places

From: Erik Carstensen <erik.carstensen@intel.com>


---
 src/methodsandresults.tex |   28 ++++++++++++++--------------
 1 file changed, 14 insertions(+), 14 deletions(-)

diff --git a/src/methodsandresults.tex b/src/methodsandresults.tex
index 2196032..c5848f8 100644
--- a/src/methodsandresults.tex
+++ b/src/methodsandresults.tex
@@ -18,7 +18,7 @@ The tool generates all but the methods that need special treatment (due to state
 \subsection{Target System Libraries}
 \label{sec:proposedsolutionandimplementation_targetsystemlibraries}
 Compiled from \texttt{C} and \texttt{C++} sources output by the generation program, the target system libraries compose implementations of the EGL and OpenGL APIs.
-Due to the tight coupling ibetween OpenGL and the platform windowing system, the solution must also accelerate the Khronos EGL API - the interface between OpenGL and the underlying platform windowing system.
+Due to the tight coupling ibetween OpenGL and the platform windowing system, the solution must also accelerate the Khronos EGL API -- the interface between OpenGL and the underlying platform windowing system.
 As may be derived from the name, the target system libraries run on the simulation target system and replace any existing Khronos libraries.
 
 Accordingly, the target system libraries implement the EGL and OpenGL~ES~$2.0$ APIs and lures whatever application it is being linked to that it is, in fact, the expected platform libraries.
@@ -60,7 +60,7 @@ In this way, the problem arises of a conflict between wanting to keep the functi
  
 This issue is overcome by overriding symbols in the target libraries, which allows us to overload a function, serialize and forward the invocation to the host system, locate the next occurrence of the symbol in the symbol table (being the original native EGL function definition), and invoke the original function.
 Accordingly, the target system EGL library does not replace the native target EGL library in its entirety, as with the OpenGL library, but rather extends it a bit.
-This gives the effect of a successfully created window, not having returned any errors in the window creation and maintenance - yet having the application actually communicating with a different window.
+This gives the effect of a successfully created window, not having returned any errors in the window creation and maintenance -- yet having the application actually communicating with a different window.
 As such, the target system libraries are effectively performing a man-in-the-middle attack on the target EGL library.
 
 % Simics Pipe
@@ -72,7 +72,7 @@ In order to do this, the pipe requires a way to exchange information with the ou
 
 There may be reasons as to why one would like to escape the simulation and resume execution in the real world.
 Such a scenario would be a debugging breakpoint, to share data in-between target and host systems, or for any reason modify the simulation state.
-There are a number of ways to communicate with the outside world (including the host machine) from within the simulation, such as by networking means or specially devised kernel drivers, but few are as instant as the - arguably - legitimately coined 'magic instruction'.
+There are a number of ways to communicate with the outside world (including the host machine) from within the simulation, such as by networking means or specially devised kernel drivers, but few are as instant as the -- arguably -- legitimately coined 'magic instruction'.
 
 The magic instruction is a concept used to denote a \dvtcmdcodeinline{nop}-type instruction, meaning an instruction that would have no effect if run on the target architecture (such as \dvtcmdcodeinline{xchg ebx, ebx} on the x86), which, when executed on the simulated hardware in a virtual platform, invokes a callback-method in the simulation host~\dvtcmdcitebib[p.~32]{publications:leupers:2010}.
 An advantage of this methodology is an often negligible invocation cost, as the context switch is often instant from the perspective of the target system~\dvtcmdcitebib[p.~131]{journals:rechistov:2013}.
@@ -81,7 +81,7 @@ In effect, implementation of magic instructions requires replacing one or more i
 However, the solution is often designed to only respond to magic instructions wherein a certain magic number, sometimes called a 'leaf number'~\dvtcmdcitebib[p.~131]{journals:rechistov:2013}, is present in an arbitrary processor register.
 
 Due to the inherent performance demands brought on by serialization of real-time graphics invocations, magic instructions are a suitable candidate to exchange information between target host systems.
-Magic instructions allow for fast, in the pretext of the simulation target - almost instant - escape from the simulation context, and may carry a limited amount of information with it from inside the simulation out into the real world.
+Magic instructions allow for fast, in the pretext of the simulation target -- almost instant -- escape from the simulation context, and may carry a limited amount of information with it from inside the simulation out into the real world.
 The role of the Simics pipe is comprised of the allocation and maintenance of page locked target memory to accomodate the use of magic instructions, which the Simics pipe uses to relay the starting address of said memory space to the simulation host.
 
 During a magic instruction, we may write an arbitrary 64-bit address to any register fit for purpose (the number and size of processor registers being the data-sharing bottleneck of the method).
@@ -117,7 +117,7 @@ Naturally, said process must be performed regardless of data being read or writt
 \begin{figure}
 \centering
 \includegraphics[width=\linewidth]{img/yedvirtualmemory.pdf}
-\caption[Memory translation overview]{\hl{Memory translation overview. The OpenGL process hands a virtual memory address, pointing somewhere in the target system \textit{primary} memory, to the paravirtualized solution - which inquiries the target system MMU to retrieve designated bytestream directly from target physical memory.}}
+\caption[Memory translation overview]{\hl{Memory translation overview. The OpenGL process hands a virtual memory address, pointing somewhere in the target system \textit{primary} memory, to the paravirtualized solution -- which inquiries the target system MMU to retrieve designated bytestream directly from target physical memory.}}
 \label{fig:virtualmemory}
 \end{figure}
 
@@ -169,7 +169,7 @@ The specifics of these instances are described along with the benchmarks below.
 \paragraph{Benchmark: Chess}
 \label{par:experimentalmethodology_benchmarking_benchmarkchess}
 \index{Chess benchmark}
-The 'Chess' benchmark is developed for the purposes of stressing the latency in-between target - and host systems.
+The 'Chess' benchmark is developed for the purposes of stressing the latency between target and host systems.
 It is so named because of the chess-like tileset the graphics kernel produces.
 The benchmark is designed to perform a multitude of OpenGL~ES~$2.0$ library invocations per frame, in which each invocation is relatively lightweight in execution and carries a small amount of data in its arguments.
 In the Chess benchmark, this is achieved by rendering a grid of colored (black or white, in order to adhere to the chess paradigm) rectangles where each tile is represented by four two-dimensional vertices in screen-space, in addition to six indices outlining the rectangular shape.
@@ -198,7 +198,7 @@ We perform the Julia benchmark with $225$, $450$, and $900$ iterations per frame
 \subsubsection{Platform Profiling}
 \label{sec:platformprofiling}
 In the presence of complications caused by virtual time, profiling of elapsed time in simulators dictate special measures.
-This is due to the fact that profiling of elapsed time outside of the simulation - that is, time in the context of the observer - may be more relevant than profiling of virtual time.
+This is due to the fact that profiling of elapsed time outside of the simulation -- that is, time in the context of the observer -- may be more relevant than profiling of virtual time.
 This is often the case if the simulation has outside dependencies of some sort.
 Naturally, it is so in terms of real-time interaction and rendering.
 
@@ -246,7 +246,7 @@ The remainder of this section presents an analysis of the data compiled from exe
       & \juliakeytwo & \dvtcmdfirstline{simicsjulia450.dat.min} & \dvtcmdfirstline{simicsjulia450.dat.max} & \dvtcmdfirstline{simicsjulia450.dat.std} & \dvtcmdfirstline{simicsjulia450.dat.avg} \\ %\cline{2-6}
       & \juliakeythree & \dvtcmdfirstline{simicsjulia900.dat.min} & \dvtcmdfirstline{simicsjulia900.dat.max} & \dvtcmdfirstline{simicsjulia900.dat.std} & \dvtcmdfirstline{simicsjulia900.dat.avg} \\ \hline
     \end{tabular}
-    \caption[Benchmark results - software rasterized in Simics]{Benchmarking results whilst software rasterized in the Simics full-system simulator.}
+    \caption[Benchmark results -- software rasterized in Simics]{Benchmarking results whilst software rasterized in the Simics full-system simulator.}
     \label{tab:keyvalsimics}
     \vspace{4ex}
   \end{minipage}%%
@@ -260,7 +260,7 @@ The remainder of this section presents an analysis of the data compiled from exe
       Chess & \dvtcmdfirstline{hostchess84x84.dat.min} & \dvtcmdfirstline{hostchess84x84.dat.max} & \dvtcmdfirstline{hostchess84x84.dat.std} & \dvtcmdfirstline{hostchess84x84.dat.avg} \\ \hline
       Julia & \dvtcmdfirstline{hostjulia450.dat.min} & \dvtcmdfirstline{hostjulia450.dat.max}	& \dvtcmdfirstline{hostjulia450.dat.std} & \dvtcmdfirstline{hostjulia450.dat.avg} \\ \hline
     \end{tabular}
-    \caption[Benchmark results - hardware accelerated on the simulation host]{Benchmarking results whilst hardware accelerated on the simulation host system.}
+    \caption[Benchmark results -- hardware accelerated on the simulation host]{Benchmarking results whilst hardware accelerated on the simulation host system.}
     \label{tab:keyvalhost}
     \vspace{4ex}
   \end{minipage} 
@@ -278,7 +278,7 @@ The remainder of this section presents an analysis of the data compiled from exe
       & \juliakeytwo & \dvtcmdfirstline{parajulia450.dat.min} & \dvtcmdfirstline{parajulia450.dat.max} & \dvtcmdfirstline{parajulia450.dat.std} & \dvtcmdfirstline{parajulia450.dat.avg} \\
       & \juliakeythree & \dvtcmdfirstline{parajulia900.dat.min} & \dvtcmdfirstline{parajulia900.dat.max} & \dvtcmdfirstline{parajulia900.dat.std} & \dvtcmdfirstline{parajulia900.dat.avg} \\ \hline
     \end{tabular}
-    \caption[Benchmark results - paravirtualized in Simics]{Benchmarking results whilst paravirtualized in the Simics full-system simulator.}
+    \caption[Benchmark results -- paravirtualized in Simics]{Benchmarking results whilst paravirtualized in the Simics full-system simulator.}
     \label{tab:keyvalpara}
     \vspace{4ex}
   \end{minipage}%% 
@@ -292,7 +292,7 @@ The remainder of this section presents an analysis of the data compiled from exe
       Chess & \dvtcmdfirstline{qemuchess84x84.dat.min} & \dvtcmdfirstline{qemuchess84x84.dat.max} & \dvtcmdfirstline{qemuchess84x84.dat.std} & \dvtcmdfirstline{qemuchess84x84.dat.avg} \\ \hline
       Julia & \dvtcmdfirstline{qemujulia450.dat.min} & \dvtcmdfirstline{qemujulia450.dat.max}	& \dvtcmdfirstline{qemujulia450.dat.std} & \dvtcmdfirstline{qemujulia450.dat.avg} \\ \hline
     \end{tabular}
-    \caption[Benchmark results - paravirtualized in the Android emulator]{Benchmarking results whilst paravirtualized in the QEMU-derived Android emulator.}
+    \caption[Benchmark results -- paravirtualized in the Android emulator]{Benchmarking results whilst paravirtualized in the QEMU-derived Android emulator.}
     \label{tab:keyvalqemu}
     \vspace{4ex}
   \end{minipage} 
@@ -303,11 +303,11 @@ The remainder of this section presents an analysis of the data compiled from exe
 \begin{figure*}
   \centering
   \input{gnuhistogramssimicsparachess.tex}
-  \caption[Benchmark results - paravirtualized in Simics, Chess]{Histograms depicting benchmark elapsed frametimes in milliseconds and the density distribution of 1000 frames for the Chess benchmark key figure variations whilst software rasterized- and paravirtualized in Simics. The $Y$ axis thus depict sample density. Its axis keys have been removed as they bear no relevance to the outcomes presented in this document.}
+  \caption[Benchmark results -- paravirtualized in Simics, Chess]{Histograms depicting benchmark elapsed frametimes in milliseconds and the density distribution of 1000 frames for the Chess benchmark key figure variations whilst software rasterized- and paravirtualized in Simics. The $Y$ axis thus depict sample density. Its axis keys have been removed as they bear no relevance to the outcomes presented in this document.}
   \label{fig:histogramssimicsparachess}
 
   \input{gnuhistogramssimicsparajulia.tex}
-  \caption[Benchmark results - paravirtualized in Simics, Julia]{Histograms depicting benchmark elapsed frametimes in milliseconds and the density distribution of 1000 frames for the Julia benchmark key figure variations whilst software rasterized- and paravirtualized in Simics. The $Y$ axis thus depict sample density. Its axis keys have been removed as they bear no relevance to the outcomes presented in this document.}
+  \caption[Benchmark results -- paravirtualized in Simics, Julia]{Histograms depicting benchmark elapsed frametimes in milliseconds and the density distribution of 1000 frames for the Julia benchmark key figure variations whilst software rasterized- and paravirtualized in Simics. The $Y$ axis thus depict sample density. Its axis keys have been removed as they bear no relevance to the outcomes presented in this document.}
   \label{fig:histogramssimicsparajulia}
 \end{figure*}
 
@@ -337,7 +337,7 @@ What causes this behavior is unclear, as frame-to-frame branching in the fractal
 
 The Julia benchmark is incorporated into the experiment to establish how the paravirtualized solution performed under computational stress, which is where benefits induced by hardware acceleration should be made apperent.
 Using this benchmark, we highlight weaknesses in Simics software rasterization, with frame times well above the two second mark; the corresponding maximum frame time in the paravirtualized Simics platform measuring up to to a mere \dvtcmdfirstline{parajulia900.dat.max} ms.
-As visualized in figure \ref{fig:histogramssimicsparajulia}, we showcase considerable performance improvements and - in turn - identify the capabilities of graphics paravirtualization in the Simics full-system simulator.
+As visualized in figure \ref{fig:histogramssimicsparajulia}, we showcase considerable performance improvements and -- in turn -- identify the capabilities of graphics paravirtualization in the Simics full-system simulator.
 
 % Albeit the hardware accelerated host profiling (see figure \ref{fig:histogramshost}) may, however minor, suggest such a pattern; it is by all means not significant.
 % We may observe similar behavior in the distribution of the sample density when profiling the same benchmark whilst paravirtualized in the QEMU -derived Android emulator (see figure \ref{fig:histogramsqemu}).

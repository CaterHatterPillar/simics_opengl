"foo- and bar blurp" -> "foo and bar blurp"

From: Erik Carstensen <erik.carstensen@intel.com>


---
 src/conclusion.tex        |    2 +-
 src/introduction.tex      |    6 +++---
 src/methodsandresults.tex |   14 +++++++-------
 3 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/src/conclusion.tex b/src/conclusion.tex
index caa8394..d549129 100644
--- a/src/conclusion.tex
+++ b/src/conclusion.tex
@@ -15,7 +15,7 @@ Additionally, beyond that of accelerated graphics, results indicates performance
 In line with stable frame rates being prerequisites for real-time applications, this further indicate, in coagency with reduced frametimes, the feasibility of utilizing paravirtualized methodologies for the purposes of accelerating graphics within virtual platforms.
 
 To summarize: We have presented a solution for graphics acceleration implemented in the Simics full-system simulator by the means of paravirtualization.
-The end-result is a solution which may generate libraries imitating EGL- and OpenGL~ES~$2.0$ libraries.
+The end-result is a solution which may generate libraries imitating EGL and OpenGL~ES~$2.0$ libraries.
 We may effectively spy on application EGL utilization, without inhibiting said exchange, allowing unmodified OpenGL applications to be accelerated from within the simulation target.
 The implementation communicates by the means of low-latency magic instructions with no limit as to how much memory may be shared.
 As such, throughout this document, we have tackled and presented several issues pertaining to paravirtualized graphics acceleration.
diff --git a/src/introduction.tex b/src/introduction.tex
index 0f95337..cd5fe5c 100644
--- a/src/introduction.tex
+++ b/src/introduction.tex
@@ -7,9 +7,9 @@ Virtual platforms are becoming an important tool in the software industry in ord
 Virtual platforms deliver these time-to-market benefits in two major ways.
 First of all, virtual platforms enable pre-silicon development; that is, software development that may begin prior to next-generation hardware being available~\dvtcmdcitebib[p.~52]{journals:magnusson:2002}.
 Secondly, virtual platforms may provide additional development tools compared to working with actual hardware.
-For example, some virtual platforms allow simulated systems, often known as simulation targets, to be stopped synchronously without affecting timing or states of the target software~\dvtcmdcitebib[p.~61]{inproceedings:yu:2012}, and allow investigation of race conditions and other parallel programming issues~\dvtcmdcitebib[p.~1]{inproceedings:schumacher:2010, publications:leupers:2010}.
+For example, some virtual platforms allow simulated systems, often known as simulation targets, to be stopped synchronously without affecting timing or state of the target software~\dvtcmdcitebib[p.~61]{inproceedings:yu:2012}, and allow investigation of race conditions and other parallel programming issues~\dvtcmdcitebib[p.~1]{inproceedings:schumacher:2010, publications:leupers:2010}.
 Additionally, such platforms may allow intricate inspection of simulated hardware, such as memory, caches, and registers~\dvtcmdcitebib[p.~54]{journals:magnusson:2002}.
-Some virtual platforms provide advanced features such as reverse execution (the ability to run a simulation backwards) and checkpointing (functionality to save- and restore the state of a simulation).
+Some virtual platforms provide advanced features such as reverse execution (the ability to run a simulation backwards) and checkpointing (functionality to save and restore the state of a simulation).
 These features are useful for debugging and testing a diverse range of software, from firmware to end-user applications~\dvtcmdcitebib[p.~25]{publications:leupers:2010}.
 
 There are several techniques to provide fast functional virtual platforms that are running CPU workloads.
@@ -19,7 +19,7 @@ Virtual platforms using these techniques can typically achieve a simulation perf
 The GPU is a vital part in delivering good user experiences on many devices ranging from wearable, hand held, and portable units, to desktop computers.
 Since GPUs operate significantly different from CPUs, utilizing massively parallelized instruction sets to increase throughput, they continue to pose unique challenges to designers and developers~\dvtcmdcitebib[ch.~13]{publications:kirk:2010}.
 The increased utilization of GPUs for general purpose workloads has extended the need for virtualization of such hardware in situations when hardware is busy, unavailable, not sufficient, or for the purposes of debugging and profiling~\dvtcmdciteref{web:microsoft:2013:warp}.
-For example, developers interested in benchmarking or driver development for next generation GPU- or CPUs may require detailed simulators that provide insight into execution engines and pipelines~\dvtcmdcitebib[p.~1]{inproceedings:schumacher:2010}.
+For example, developers interested in benchmarking or driver development for next generation GPUs or CPUs may require detailed simulators that provide insight into execution engines and pipelines~\dvtcmdcitebib[p.~1]{inproceedings:schumacher:2010}.
 Albeit applicable in certain use-cases and capable of running 'toy' applications, such platforms are often orders of magnitude too slow to run commercial workloads~\dvtcmdcitebib[p.~50]{journals:magnusson:2002}.
 Application developers, on the other hand, do not necessarily care for the internal workings of hardware as they typically work at a higher abstraction level.
 As such, some developers may be more interested in achieving decent simulation performance rather than a timing-accurate processor model (see \dvtcmdcitebib[p.~30]{publications:leupers:2010} for an analysis of compromises in system simulation).
diff --git a/src/methodsandresults.tex b/src/methodsandresults.tex
index c5848f8..bdbe3a2 100644
--- a/src/methodsandresults.tex
+++ b/src/methodsandresults.tex
@@ -10,7 +10,7 @@ These components, along with elaboration of the methodologies accomodating them,
 % OpenGL Framework Generation
 \subsection{OpenGL Framework Generation}
 \label{sec:proposedsolutionandimplementation_openglabigeneration}
-For the purposes of ensuring scalability of the solution during development, a set of scripts automating the generation of library source code is used to compile the majority of target- and host system libraries.
+For the purposes of ensuring scalability of the solution during development, a set of scripts automating the generation of library source code is used to compile the majority of target and host system libraries.
 As such, a large amount of the OpenGL function definitions encoded and decoded by the these libraries are produced by this tool.
 For this, we use a \texttt{Python} program that, from framework specification files detailing function signatures and argument attributes, generate both headers and source files in \texttt{C}, thus constructing the target OpenGL and EGL frameworks, along with the corresponding host decoding libraries.
 The tool generates all but the methods that need special treatment (due to state saving) and may thus generate methods with return values and inout arguments.
@@ -29,7 +29,7 @@ However, the transmission of the command stream is not necessarily performed at
 This complex of problems involve uncertainties of the proportion of argument data, as size is not necessarily given by the user or apperent at that time.
 As such, certain serialization may have to be delayed until further information surrounding the argument dimensions have been relayed to the OpenGL library.
 Furthermore, a subset of the OpenGL state need be maintained by the target system libraries.
-These attributes are comprised by, inter alia, bound vertex- and index element buffers, in addition to properties of OpenGL vertex attributes.
+These attributes are comprised by, inter alia, bound vertex and index element buffers, in addition to properties of OpenGL vertex attributes.
 Such states must be kept in the target system libraries due to the asynchronous nature of serialization of OpenGL invocations in the paravirtualized solution.
 
 The serialization described in the above paragraph is thus formatted and encoded in accordance to a certain data format, which is kept as minimal as possible throughout execution.
@@ -45,7 +45,7 @@ Said decoding involves unpacking data from fixed length storage into variable-si
 Furthermore, and again similarly to the target system libraries, due to design inherent in the OpenGL~ES~$2.0$ framework, the host system libraries need maintain some data for state saving purposes.
 Such data is buffered in the host system libraries until used (drawn) in a later, and separate, OpenGL invocation.
 %\footnote{A possible optimization would be to cache said data, to avoid the need to transmit unmodified vertices multiple times, despite so being specified by the user.}.
-When the requested OpenGL invocation has been performed, any return- or in-out values are returned to the target system using the Simics pipe.
+When the requested OpenGL invocation has been performed, any return or inout values are returned to the target system using the Simics pipe.
 As with the the target system libraries, the receiving end of an OpenGL method definitions in the host system libraries are likewise generated to a large degree.
 
 % Windowing Systems
@@ -174,9 +174,9 @@ It is so named because of the chess-like tileset the graphics kernel produces.
 The benchmark is designed to perform a multitude of OpenGL~ES~$2.0$ library invocations per frame, in which each invocation is relatively lightweight in execution and carries a small amount of data in its arguments.
 In the Chess benchmark, this is achieved by rendering a grid of colored (black or white, in order to adhere to the chess paradigm) rectangles where each tile is represented by four two-dimensional vertices in screen-space, in addition to six indices outlining the rectangular shape.
 Since the vertices are already transformed into screen-space, the graphics kernel need perform no additional transformation, adhering to the desired lightweight behavior of each kernel invocation.
-Additionally, the tileset vertices and indices are pre-loaded into OpenGL vertex- and index element buffers, so that a lone buffer identifier may be carried over in-place of the heavier vertex set load.
+Additionally, the tileset vertices and indices are pre-loaded into OpenGL vertex and index element buffers, so that a lone buffer identifier may be carried over in-place of the heavier vertex set load.
 Each tile is then individually drawn to the backbuffer, rendering the chess-like appearance of the benchmark.
-Effectively, this means that, for each tile, the benchmark need only bind a vertex- and an index element buffer, set the corresponding tile color, and lastly invoke the rendering of said tile.
+Effectively, this means that, for each tile, the benchmark need only bind a vertex and an index element buffer, set the corresponding tile color, and lastly invoke the rendering of said tile.
 
 For each frame rendered, depending on the number of drawn tiles, the solution will perform a large number of magic instructions.
 This induces a high utilization of the Simics Pipe, which is intended to stress magic instruction overhead (section \ref{sec:results_magicinstructionoverhead}).
@@ -303,11 +303,11 @@ The remainder of this section presents an analysis of the data compiled from exe
 \begin{figure*}
   \centering
   \input{gnuhistogramssimicsparachess.tex}
-  \caption[Benchmark results -- paravirtualized in Simics, Chess]{Histograms depicting benchmark elapsed frametimes in milliseconds and the density distribution of 1000 frames for the Chess benchmark key figure variations whilst software rasterized- and paravirtualized in Simics. The $Y$ axis thus depict sample density. Its axis keys have been removed as they bear no relevance to the outcomes presented in this document.}
+  \caption[Benchmark results -- paravirtualized in Simics, Chess]{Histograms depicting benchmark elapsed frametimes in milliseconds and the density distribution of 1000 frames for the Chess benchmark key figure variations whilst software rasterized and paravirtualized in Simics. The $Y$ axis thus depict sample density. Its axis keys have been removed as they bear no relevance to the outcomes presented in this document.}
   \label{fig:histogramssimicsparachess}
 
   \input{gnuhistogramssimicsparajulia.tex}
-  \caption[Benchmark results -- paravirtualized in Simics, Julia]{Histograms depicting benchmark elapsed frametimes in milliseconds and the density distribution of 1000 frames for the Julia benchmark key figure variations whilst software rasterized- and paravirtualized in Simics. The $Y$ axis thus depict sample density. Its axis keys have been removed as they bear no relevance to the outcomes presented in this document.}
+  \caption[Benchmark results -- paravirtualized in Simics, Julia]{Histograms depicting benchmark elapsed frametimes in milliseconds and the density distribution of 1000 frames for the Julia benchmark key figure variations whilst software rasterized and paravirtualized in Simics. The $Y$ axis thus depict sample density. Its axis keys have been removed as they bear no relevance to the outcomes presented in this document.}
   \label{fig:histogramssimicsparajulia}
 \end{figure*}
 
